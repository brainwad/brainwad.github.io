<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <style>
        small {
            font-size: 12px;
        }

        ul {
            padding-left: 24px;
        }

        body {
            background-color: black;
            color: lightgrey;
            font-family: 'Anonymous Pro', 'Consolas', 'Courier New', 'Courier', monospace;
        }
        
        input[type=text], input[type=number] {
            color: black;
            background-colour: white;
        }

        input {
            font-family: inherit;
        }

        li {
            list-style-type: none;
        }

        li.rank0 {
            list-style-type: "\1F947";
            text-decoration: underline;
        }

        li.rank1 {
            list-style-type: "\1F948";
        }

        li.rank2 {
            list-style-type: "\1F949";
        }

        @media (max-width: 799px) {
            #map {
                height: 100vw;
            }
        }

        @media (min-width: 800px) {
            #container {
                display: flex;
                height: 100%;
            }

            #map {
                flex: 75%;
            }

            #sidebar {
                flex: 25%;
            }
        }

        label {
            display: flex
        }

        #from,
        #to {
            flex-grow: 1;
        }

        #graph {
            width: 100%;
            height: 8em;
            margin: -1em 0;
        }

        #progress {
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="map"></div>
        <div id="sidebar">
            <form>
                <datalist id="from_address">
                    <option>current location</option>
                    <option>from contacts...</option>
                </datalist>
                <datalist id="to_address">
                    <option>from contacts...</option>
                </datalist>
                <label>from: <input id="from" list="from_address" autocomplete="on" type=text
                        placeholder="current location"><input type="button" value="✕"
                        onclick="document.getElementById('from').value='';"></label>
                <label>to: <input id="to" list="to_address" autocomplete="on" type=text><input type="button" value="✕"
                        onclick="document.getElementById('to').value='';"></label>
                <input type="button" value="▶" onclick="stop(); go()">
                <input type="button" value="⇅" onclick="stop(); reverse(); go()">
                <input type="button" value="✕" onclick="stop();">
                ⌛$<input id=hour-cost value="70" min="0" type=number style="width:3.6em"
                    onchange="render_efficient_frontier(/*force=*/true)">/hr
                ⛽$<input id=fuel-cost value="1.90" min="0" type=number step="0.01" style="width:4.1em"
                    onchange="render_efficient_frontier(/*force=*/true)">/L
                <input type="button" value="⚙️" onclick="api_key_prompt()">
            </form>
            <p id=progress></p>
            <div id=graph style="display:none"></div>
            <ul id=results></ul>
        </div>
    </div>

    <script src="https://js.api.here.com/v3/3.1/mapsjs-core.js" type="text/javascript" charset="utf-8"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-service.js" type="text/javascript" charset="utf-8"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="js-colormaps.js"></script>
    <script>
        // From https://opendata.transport.nsw.gov.au/node/7407/exploreapi#!/pricing/getData. Cannot be loaded on the fly due to CORS :(
        var toll_data;
        fetch("./tolls.json").then(async (r) => toll_data = await r.json());

        var handle_enter = ({ key }) => { if (key === "Enter" && document.getElementById("to").value) { stop(); go(); } }
        document.getElementById("from").addEventListener("keypress", handle_enter);
        document.getElementById("to").addEventListener("keypress", handle_enter);
        var handle_input = async (e) => {
            if (!(e instanceof InputEvent) || e.inputType == "insertReplacementText") {
                if (e.target.id == "from" && e.target.value == "current location") {
                    e.target.value = "";
                } else if (e.target.value == "from contacts...") {
                    e.target.value = "";
                    if ('contacts' in navigator &&
                        'ContactsManager' in window &&
                        (await navigator.contacts.getProperties()).includes("address")) {
                        const contacts = await navigator.contacts.select(["address"], {});
                        if (contacts.length && contacts[0].address.length && contacts[0].address[0].addressLine.length) {
                            e.target.value = contacts[0].address[0].addressLine.map((x) => x.replaceAll("\n", ", ")).join(", ");
                        }
                    }
                }
                if (document.getElementById("to").value) {
                    stop(); go();
                }
            }
        }
        document.getElementById("from").addEventListener("input", handle_input);
        document.getElementById("to").addEventListener("input", handle_input);

        function set_value_from_local_storage(id) {
            if (localStorage.getItem("tolls-" + id)) {
                document.getElementById(id).value = localStorage.getItem("tolls-" + id);
            }
        }
        function save_value_to_local_storage(e) {
            if (e.target.value) {
                localStorage.setItem("tolls-" + e.target.id, e.target.value);
            }
        }
        set_value_from_local_storage("hour-cost");
        set_value_from_local_storage("fuel-cost");
        document.getElementById("hour-cost").addEventListener("change", save_value_to_local_storage)
        document.getElementById("fuel-cost").addEventListener("change", save_value_to_local_storage)

        function api_key_prompt() {
            const prev = localStorage.getItem("HERE_API_KEY");
            const input = prompt("(Required) HERE Maps API Key:", prev ? prev : "");
            if (input) {
                localStorage.setItem("HERE_API_KEY", input);
            } else {
                localStorage.removeItem("HERE_API_KEY");
            }
        }

        while (!localStorage.getItem("HERE_API_KEY")) {
            api_key_prompt();
        }
        var platform = new H.service.Platform({ 'apikey': localStorage.getItem("HERE_API_KEY") });
        var maptypes = platform.createDefaultLayers();
        var map = new H.Map(
            document.getElementById('map'),
            maptypes.raster.normal.mapnight,
            {
                zoom: 11,
                center: { lng: 151, lat: -33.85 },
                padding: { top: 20, left: 20, right: 20, bottom: 20 }
            });
        var background_polylines = new H.map.Group();
        var frontier_polylines = new H.map.Group();
        map.addObjects([background_polylines, frontier_polylines]);
        var searchService = platform.getSearchService();
        var routingService = platform.getRoutingService(null, 8);

        var from;
        var to;
        var bounding_box;
        var routes = [];
        var frontier_routes = [];
        var tried_avoids = [];
        var initiated_requests = 0;
        var successful_requests = 0;
        var start_time;
        var recent_route_responses = [];

        var stop = function () {
            start_time = null;
            from = null;
            to = null;
            bounding_box = null;
            tried_avoids = [];
            recent_route_responses = [];
        }

        var go = function () {
            document.getElementById("progress").innerHTML = "";
            document.getElementById("results").innerHTML = "";
            document.getElementById("graph").style = "display: none";
            background_polylines.removeAll();
            frontier_polylines.removeAll();
            bounding_box = null;
            routes = [];
            initiated_requests = 0;
            successful_requests = 0;
            start_time = new Date();

            continuation = function () {
                searchService.autosuggest({ q: document.getElementById("from").value, at: '-33.85,151' }, (result) => {
                    from = result.items[0];
                    document.getElementById("from").value = from.title;
                    searchService.autosuggest({ q: document.getElementById("to").value, at: '-33.85,151' }, (result) => {
                        to = result.items[0];
                        document.getElementById("to").value = to.title;
                        tried_avoids = [[]];
                        routes = [];
                        calculateRoute(from, to, { features: ["tollRoad"] });
                        calculateRoute(from, to, {});
                    }, alert);
                }, alert);
            }
            if (document.getElementById("from").value && document.getElementById("to").value) {
                continuation()
            } else if (document.getElementById("to").value) {
                document.getElementById("from").placeholder = "Geolocating..."
                navigator.geolocation.getCurrentPosition(
                    (position) => { document.getElementById("from").value = `${position.coords.latitude.toFixed(7)}, ${position.coords.longitude.toFixed(7)}`; continuation() },
                    (error) => { document.getElementById("from").placeholder = error.message },
                    { enableHighAccuracy: true }
                );
            } else {
                document.getElementById("to").placeholder = "enter a destination :)"
            }
        }

        async function calculateRoute(from, to, avoid) {
            initiated_requests += 1;
            var params = {
                'origin': `${from.position.lat},${from.position.lng}`,
                'destination': `${to.position.lat},${to.position.lng}`,
                'alternatives': 0,
                'currency': 'aud',
                'return': ["polyline", "elevation", "tolls", "summary", "travelSummary"],
                'spans': ["segmentRef", "dynamicSpeedInfo", "functionalClass", "names", "routeNumbers", "length", "duration", "streetAttributes", "carAttributes"],
                'tolls[summaries]': 'total',
                'transportMode': 'car',
                'units': 'metric',
            };
            if (avoid.hasOwnProperty("features")) {
                params = Object.assign(params, { 'avoid[features]': avoid.features });
            }
            if (avoid.hasOwnProperty("segments")) {
                params = Object.assign(params, { 'avoid[segments]': avoid.segments });
            }
            var make_request = async () => {
                await new Promise(resolve => {
                    const expected_start_time = start_time;
                    recent_route_responses = recent_route_responses.filter(x => Date.now() - x.time < 10000);
                    const error_ratio = recent_route_responses.filter(x => !x.ok).length / Math.max(1, recent_route_responses.filter(x => x.ok).length);
                    const sleep_time = 1 / 10 * error_ratio;
                    console.log(`Sleeping before computing route for ${sleep_time} seconds`);
                    setTimeout(() => {
                        if (start_time && start_time == expected_start_time) {
                            resolve()
                        } else {
                            throw new Error("route request is stale after sleep")
                        }
                    }, sleep_time * 1000)
                });
                const expected_start_time = start_time;
                routingService.calculateRoute(params, (result) => {
                    if (!start_time || start_time != expected_start_time) {
                        throw new Error("route response is stale")
                    }
                    if (!result.routes.length) {
                        throw new Error("route response is empty", { cause: result })
                    }
                    recent_route_responses.push({ time: Date.now(), ok: true });
                    let route = result.routes[0].sections[0];
                    route.start_time = start_time;
                    route.avoid = avoid;
                    handle_route(route)
                }, async (error) => {
                    if (start_time && start_time.getTime() < Date.now()) {
                        recent_route_responses.push({ time: Date.now(), ok: false });
                        make_request();
                    }
                });
            };
            make_request();
        }

        function is_fixed_rate_tollway(name) {
            return [
                "Bradfield Hwy",
                "Cahill Expy",
                "Eastern Distributor",
                "Falcon St (ramp)",
                "Lane Cove Tunnel",
                "Northconnex",
                "South Western Mtwy",
                "Sydney Harbour Tunnel",
            ].includes(name)
        }

        function get_toll_data_for(motorway_key) {
            var filtered = toll_data.motorways.filter(x => x.motorwayRef == motorway_key);
            if (filtered.length != 1) return;
            return filtered[0];
        }

        function get_fixed_toll_at(motorway_toll_data, gantry_code) {
            console.assert(motorway_toll_data.chargeType == "Fixed", "not a fixed tolled motorway!");
            filtered_gantries = motorway_toll_data.gantries.filter(x => x.gantryRef == gantry_code)
            if (filtered_gantries.length != 1) throw new Error(`couldn't find gantry ${entry_gantry_code}`);
            filtered_charges = filtered_gantries[0].charges.filter(x => x.vehicleClass == "A");
            if (filtered_charges.length != 1) throw new Error("couldn't find class A charges");
            return filtered_charges[0].chargeInCents / 100;
        }

        function get_distance_toll_between(motorway_toll_data, entry_gantry_code, exit_gantry_code) {
            console.assert(motorway_toll_data.chargeType == "Distance", "not a distance tolled motorway!");
            filtered_gantries = motorway_toll_data.gantries.filter(x => x.gantryRef == entry_gantry_code);
            if (filtered_gantries.length != 1) throw new Error(`couldn't find gantry ${entry_gantry_code}`);
            if (!filtered_gantries[0].exitGantries) throw new Error(`${entry_gantry_code} has no exit gantries`);
            filtered_exits = filtered_gantries[0].exitGantries.filter(x => x.gantryRef == exit_gantry_code);
            if (filtered_exits.length != 1) throw new Error(`couldn't find gantry ${exit_gantry_code}`);
            filtered_charges = filtered_exits[0].charge.filter(x => x.vehicleClass == "A");
            if (filtered_charges.length != 1) throw new Error("couldn't find class A charges");
            return filtered_charges[0].chargeInCents / 100;
        }

        function get_timed_toll_at(motorway_toll_data, time_str, day_of_week) {
            console.assert(motorway_toll_data.chargeType == "TimeofDay", "not a distance tolled motorway!");
            for (charge of motorway_toll_data.gantries[0].charges.filter(x => x.dayOfWeek == day_of_week)) {
                if (time_str >= charge.startTime && time_str < charge.endTime) {
                    return charge.chargeInCents / 100;
                }
            }
        }

        function infer_fixed_gantry(motorway_toll_data, toll_road) {
            console.assert(motorway_toll_data.chargeType == "Fixed", "not a fixed tolled motorway!");
            let best_dist_sq;
            let best_gantry;
            for (let gantry of motorway_toll_data.gantries) {
                for (var i = 3; i < toll_road.shape.length; i += 3) {
                    const a = [toll_road.shape[i-3], toll_road.shape[i-2]];
                    const b = [toll_road.shape[i], toll_road.shape[i+1]];
                    const [lat, lng] = closestPointBetween2D([gantry.latitude, gantry.longitude], a, b);
                    const dist_sq = (lat - gantry.latitude) ** 2 + (lng - gantry.longitude) ** 2;
                    if (!best_dist_sq || best_dist_sq > dist_sq) {
                        best_gantry = gantry;
                        best_dist_sq = dist_sq;
                    }
                }
            }
            toll_road.gantry = best_gantry;
            return best_gantry;
        }

        function infer_fixed_highest_toll_gantry(motorway_toll_data, toll_road, max_dist_sq) {
            console.assert(motorway_toll_data.chargeType == "Fixed", "not a fixed tolled motorway!");
            let best_gantry;
            for (let gantry of motorway_toll_data.gantries) {
                for (var i = 3; i < toll_road.shape.length; i += 3) {
                    const a = [toll_road.shape[i-3], toll_road.shape[i-2]];
                    const b = [toll_road.shape[i], toll_road.shape[i+1]];
                    const [lat, lng] = closestPointBetween2D([gantry.latitude, gantry.longitude], a, b);
                    const dist_sq = (lat - gantry.latitude) ** 2 + (lng - gantry.longitude) ** 2;
                    if (dist_sq < max_dist_sq && (!best_gantry || best_gantry.chargeInCents < gantry.chargeInCents)) {
                        best_gantry = gantry;
                    }
                }
            }
            toll_road.gantry = best_gantry;
            return best_gantry;
        }

        function infer_distance_gantries(motorway_toll_data, toll_road) {
            console.assert(motorway_toll_data.chargeType == "Distance", "not a distance tolled motorway!");
            const entry_gantries = motorway_toll_data.gantries.filter(x => x.exitGantries);
            let best_dist_sq;
            let best_entry_gantry;
            let best_exit_gantry;
            for (const entry_gantry of entry_gantries) {
                const entry_lat = toll_road.shape[0];
                const entry_lng = toll_road.shape[1];
                const exit_gantries = motorway_toll_data.gantries.filter(x => entry_gantry.exitGantries.filter(y => y.gantryRef == x.gantryRef).some((x) => x));
                for (const exit_gantry of exit_gantries) {
                    const exit_lat = toll_road.shape[toll_road.shape.length - 3];
                    const exit_lng = toll_road.shape[toll_road.shape.length - 2];
                    const dist_sq =
                        (entry_lat - entry_gantry.latitude) ** 2 +
                        (entry_lng - entry_gantry.longitude) ** 2 +
                        (exit_lat - exit_gantry.latitude) ** 2 +
                        (exit_lng - exit_gantry.longitude) ** 2;
                    if (!best_dist_sq || best_dist_sq > dist_sq) {
                        best_entry_gantry = entry_gantry;
                        best_exit_gantry = exit_gantry;
                        best_dist_sq = dist_sq;
                    }
                }
            }
            toll_road.entry_gantry = best_entry_gantry;
            toll_road.exit_gantry = best_exit_gantry;
            return [best_entry_gantry, best_exit_gantry];
        }

        function infer_timed_gantry_time(motorway_toll_data, toll_road, max_dist_sq) {
            console.assert(motorway_toll_data.chargeType == "TimeofDay", "not a time-of-day tolled motorway!");
            let best_span;
            let best_dist_sq;
            for (let span of toll_road.spans) {
                for (let i = 0; i < span.shape.length; i += 3) {
                    let lat = span.shape[i];
                    let lng = span.shape[i + 1];
                    let dist_sq = (lat - motorway_toll_data.gantries[0].latitude) ** 2 + (lng - motorway_toll_data.gantries[0].longitude) ** 2;
                    if (dist_sq < max_dist_sq && (!best_dist_sq || best_dist_sq > dist_sq)) {
                        best_span = span;
                        best_dist_sq = dist_sq;
                    }
                }
            }
            if (best_span) {
                toll_road.gantry = motorway_toll_data.gantries[0];
                let time_str = best_span.start_time.toLocaleTimeString('en-AU', { hour: "2-digit", minute: "2-digit", hour12: false, timeZone: "Australia/Sydney" }).replace(":","");
                switch (new Date().toLocaleDateString('en-AU', { weekday: "long", timeZone: "Australia/Sydney" })) {
                    case "Saturday":
                    case "Sunday":
                        return [time_str, "WEEKEND"];
                        break;
                    default:
                        return [time_str, "WEEKDAY"];
                }
            }
        }

        function decorate_spans(route) {
            let span_start_time = new Date(start_time.getTime());
            for (let span of route.spans) {
                span.start_time = span_start_time;
                span_start_time = new Date(span_start_time.getTime() + span.duration * 1000);
                for (const k in route.refReplacements) {
                    span.segmentRef = span.segmentRef.replace(`$${k}`, route.refReplacements[k]);
                }
                span.segmentRef = span.segmentRef.match(/here:cm:segment:\d+#./)[0]
                span.flags = [];
                if (span.hasOwnProperty("streetAttributes")) {
                    span.flags = span.flags.concat(span.streetAttributes);
                }
                if (span.hasOwnProperty("carAttributes")) {
                    span.flags = span.flags.concat(span.carAttributes);
                }
                span.roadName = "";
                if (span.hasOwnProperty("names")) {
                    for (let name of span.names) {
                        if (name.language == "en" && name.value != "Light Horse Intr") {
                            span.roadName = name.value;
                            break;
                        }
                    }
                }
                span.roadNumber = ""
                if (span.hasOwnProperty("routeNumbers")) {
                    for (let name of span.routeNumbers) {
                        if (name.language == "en") {
                            span.roadNumber = name.value;
                            break;
                        }
                    }
                }
                // fix broken names
                if (span.roadName == "M7 Cycleway") {
                    span.roadName = "Westlink M7";
                } else if (span.roadName == "M4 East" || (span.flags.includes("tollRoad") && span.roadName == "Western Mtwy")) {
                    span.roadName = "Westconnex";
                } else if (span.roadName == "High St" && span.flags.includes("tollRoad")) {
                    span.roadName = "Cahill Expy";
                } else if (span.roadNumber == "M8") {
                    span.roadName = "Westconnex"
                } else if (span.roadName == "Edward Ln" && span.flags.includes("tollRoad")) {
                    span.roadName = "Westconnex"
                } else if (span.roadName == "Norwest Blvd" && span.flags.includes("tollRoad")) {
                    span.roadName = "Westlink M7"
                } else if (span.roadName == "Pennant Hills Rd" && span.flags.includes("tollRoad")) {
                    span.roadName = "Northconnex"
                } else if (span.roadName == "Gardeners Rd" && span.flags.includes("tollRoad")) {
                    span.roadName = ""
                }

                // Fix toll-less segments of toll roads
                if (!span.flags.includes("tollRoad") && (span.roadName == "Westlink M7" || span.roadName == "Westconnex")) {
                    span.flags.push("tollRoad")
                }
            }
            let shape = H.geo.LineString.fromFlexiblePolyline(route.polyline).getLatLngAltArray();
            for (let i = 0, j = 0; i < shape.length / 3; i++) {
                if (j + 1 < route.spans.length && i == route.spans[j + 1].offset) {
                    j++;
                }
                if (!route.spans[j].shape) {
                    route.spans[j].shape = []
                }
                route.spans[j].shape = route.spans[j].shape.concat(shape.slice(i * 3, (i + 1) * 3));
            }
        }

        function calculate_tolls(route) {
            let toll_roads = [];
            let last_roadName;
            let current_toll_road = null;
            let mid_toll_split = false;
            for (let span of route.spans) {
                // fix blank exits
                if (toll_roads.length && toll_roads[toll_roads.length - 1].exit == "" && span.roadName) {
                    toll_roads[toll_roads.length - 1].exit = span.roadName
                }
                if (current_toll_road && (!span.flags.includes("tollRoad") || (span.roadName && current_toll_road.name && span.roadName != current_toll_road.name))) {
                    mid_toll_split = span.flags.includes("tollRoad");

                    current_toll_road.exit = span.roadName;
                    // Special case for Falcon St southbound e-ramp, which has no name at all
                    if ((current_toll_road.name == "Warringah Fwy" && current_toll_road.exit == "Falcon St") ||
                        (!current_toll_road.name && current_toll_road.entry == "Falcon St" && current_toll_road.exit == "Warringah Fwy")) {
                        current_toll_road.name = "Falcon St (ramp)"
                    }
                    // Special case for M4 East Parramatta Rd - there are 2 exits, the old one and the new one.
                    if (current_toll_road.name == "Westconnex" && current_toll_road.spans.filter(x => x.flags.includes("tunnel")).length) {
                        if (current_toll_road.exit == "Parramatta Rd") {
                            current_toll_road.exit += " (tunnel)"
                        }
                        if (current_toll_road.entry == "Parramatta Rd") {
                            current_toll_road.entry += " (tunnel)"
                        }
                    }

                    // fixed rate toll roads have an optimisation to block the whole road at once.
                    // variable rate ones block just the start or end link.
                    if (is_fixed_rate_tollway(current_toll_road.name)) {
                        current_toll_road.key_spans = [current_toll_road.spans]
                    } else {
                        current_toll_road.key_spans = [current_toll_road.spans.slice(0, 1), current_toll_road.spans.slice(current_toll_road.spans.length - 1)]
                    }

                    current_toll_road.shape = current_toll_road.spans.flatMap(s=>s.shape)

                    // Special cases for short sections of M5 East just after M8 and M2 just before Lane Cove Tunnel
                    if (!(current_toll_road.name == "M5 East Fwy" && (current_toll_road.entry == "Westconnex" || current_toll_road.exit == "Westconnex")) &&
                        !(current_toll_road.name == "M2 Hills Mtwy" && current_toll_road.entry == "Epping Rd")) {
                        toll_roads.push(current_toll_road);
                    }
                    current_toll_road = null;
                }
                if (!current_toll_road && span.flags.includes("tollRoad")) {
                    current_toll_road = new Object();
                    current_toll_road.distance = 0;
                    current_toll_road.spans = []
                    if (mid_toll_split && toll_roads.length) {
                        current_toll_road.entry = toll_roads[toll_roads.length - 1].name;
                    } else if (last_roadName) {
                        current_toll_road.entry = last_roadName;
                    }
                    current_toll_road.start_time = span.start_time;
                    mid_toll_split = false;
                }
                if (span.flags.includes("tollRoad")) {
                    current_toll_road.spans.push(span);
                    current_toll_road.distance += span.length;
                    // fill road name if not yet seen (because prior links had no name)
                    if (span.roadName && !current_toll_road.name) {
                        current_toll_road.name = span.roadName;
                    }
                }
                if (span.roadName) {
                    last_roadName = span.roadName;
                }
            }
            if (current_toll_road) {
                toll_roads.push(current_toll_road);
            }
            route.toll_roads = toll_roads;
            route.toll = 0;
            for (var road of toll_roads) {
                try {
                    switch (road.name) {
                        case "Bradfield Hwy":
                        case "Cahill Expy":
                            var time = infer_timed_gantry_time(get_toll_data_for("SHB"), road, 1e-5);
                            if (time) {
                                road.toll = get_timed_toll_at(get_toll_data_for("SHB"), time[0], time[1]);
                            }
                            break;
                        case "Cross City Tunnel":
                            road.toll = get_fixed_toll_at(get_toll_data_for("CCT"), infer_fixed_gantry(get_toll_data_for("CCT"), road).gantryRef);
                            break;
                        case "Eastern Distributor":
                            road.toll = get_fixed_toll_at(get_toll_data_for("ED"), infer_fixed_gantry(get_toll_data_for("ED"), road).gantryRef);
                            break;
                        case "Falcon St (ramp)":
                            road.toll = get_fixed_toll_at(get_toll_data_for("LCT"), infer_fixed_gantry(get_toll_data_for("LCT"), road).gantryRef);
                            break;
                        case "Lane Cove Tunnel":
                            road.toll = get_fixed_toll_at(get_toll_data_for("LCT"), infer_fixed_gantry(get_toll_data_for("LCT"), road).gantryRef);
                            break;
                        case "M2 Hills Mtwy":
                            road.toll = get_fixed_toll_at(get_toll_data_for("M2"), infer_fixed_highest_toll_gantry(get_toll_data_for("M2"), road, 2e-4).gantryRef);
                            break;
                        case "Northconnex":
                            road.toll = get_fixed_toll_at(get_toll_data_for("NCX"), infer_fixed_gantry(get_toll_data_for("NCX"), road).gantryRef);
                            break;
                        case "South Western Mtwy":
                            road.toll = get_fixed_toll_at(get_toll_data_for("M5"), infer_fixed_gantry(get_toll_data_for("M5"), road).gantryRef);
                            break;
                        case "Sydney Harbour Tunnel":
                            var time = infer_timed_gantry_time(get_toll_data_for("SHT"), road, 1e-5);
                            if (time) {
                                road.toll = get_timed_toll_at(get_toll_data_for("SHT"), time[0], time[1]);
                            }
                            break;
                        case "M5 East Fwy":
                        case "Westconnex":
                            var gantries = infer_distance_gantries(get_toll_data_for("WCX"), road);
                            road.toll = get_distance_toll_between(get_toll_data_for("WCX"), gantries[0].gantryRef, gantries[1].gantryRef);
                            break;
                        case "Westlink M7":
                            var gantries = infer_distance_gantries(get_toll_data_for("M7"), road);
                            road.toll = get_distance_toll_between(get_toll_data_for("M7"), gantries[0].gantryRef, gantries[1].gantryRef);
                            break;
                    }
                } catch { }
                if (road.toll) {
                    route.toll += road.toll;
                }
            }
            if (route.summary.tolls.total.value.toFixed(2) != route.toll.toFixed(2)) {
                console.error(`toll disagreement: HERE says $${route.summary.tolls.total.value}, I say $${route.toll}`)
            }
        }

        // Fuel efficiency curves (mph => mpg) for various road slopes for a compact (gasoline) car.
        // Source: https://scholarworks.unr.edu/bitstream/handle/11714/2809/Chkaiban_unr_0139M_12501.pdf
        // Digitised with https://apps.automeris.io/wpd/
        const fuel_efficiency_curves = [
            // Downhill
            { 0: 0, 1: 3, 5: 21, 10: 51, 15: 86, 20: 125, 25: 167, 30: 203, 35: 230, 40: 240, 45: 235, 50: 215, 55: 185, 60: 153, 65: 123, 70: 95, 75: 73, 80: 57, 85: 44, 90: 36, },
            { 0: 0, 1: 3, 5: 14, 10: 24, 15: 34, 20: 42, 25: 52, 30: 61, 35: 69, 40: 74, 45: 76, 50: 75, 55: 71, 60: 66, 65: 60, 70: 54, 75: 48, 80: 43, 85: 40, 90: 38, },
            { 0: 0, 1: 9, 5: 18, 10: 24, 15: 28, 20: 32, 25: 37, 30: 43, 35: 48, 40: 51, 45: 53, 50: 53, 55: 51, 60: 48, 65: 45, 70: 41, 75: 38, 80: 34, 85: 32, 90: 30, },
            // Uphill
            { 0: 0, 1: 8, 5: 17, 10: 25, 15: 31, 20: 36, 25: 40, 30: 44, 35: 48, 40: 50, 45: 51, 50: 49, 55: 47, 60: 45, 65: 42, 70: 38, 75: 35, 80: 32, 85: 30, 90: 28, },
            { 0: 0, 1: 7, 5: 15, 10: 21, 15: 25, 20: 29, 25: 33, 30: 36, 35: 38, 40: 39, 45: 40, 50: 39, 55: 38, 60: 36, 65: 33, 70: 31, 75: 29, 80: 27, 85: 25, 90: 24, },
            { 0: 0, 1: 8, 5: 13, 10: 18, 15: 21, 20: 24, 25: 26, 30: 28, 35: 29, 40: 30, 45: 30, 50: 30, 55: 28, 60: 27, 65: 26, 70: 24, 75: 23, 80: 22, 85: 21, 90: 20, },
            { 0: 0, 1: 7, 5: 12, 10: 15, 15: 18, 20: 19, 25: 21, 30: 22, 35: 23, 40: 23, 45: 23, 50: 23, 55: 22, 60: 22, 65: 21, 70: 20, 75: 19, 80: 18, 85: 18, 90: 17, },
            { 0: 0, 1: 7, 5: 10, 10: 13, 15: 14, 20: 15, 25: 17, 30: 18, 35: 18, 40: 18, 45: 18, 50: 18, 55: 18, 60: 17, 65: 17, 70: 16, 75: 15, 80: 15, 85: 14, 90: 13, },
            { 0: 0, 1: 6, 5: 9, 10: 11, 15: 12, 20: 12, 25: 13, 30: 14, 35: 14, 40: 14, 45: 15, 50: 15, 55: 14, 60: 14, 65: 14, 70: 13, 75: 12, 80: 12, 85: 11, 90: 10, }
        ]

        function interpolate_curve(curve, x) {
            var keys = Object.keys(curve).sort();
            if (keys[0] >= x) return curve[keys[0]];
            for (const [i, k] of keys.entries()) {
                if (k >= x) {
                    const k_ = keys[i - 1];
                    return curve[k_] + (curve[k] - curve[k_]) * (x - parseFloat(k_)) / (parseFloat(k) - parseFloat(k_));
                }
            }
            return curve[keys[keys.length - 1]];
        }

        function calculate_fuel(route) {
            route.fuel = 0;
            for (let span of route.spans) {
                if (!span.length) continue;
                var altitude_diff = span.shape.length ? span.shape[span.shape.length - 1] - span.shape[2] : 0;
                var gradient = altitude_diff / span.length;
                var gradient_class =
                    gradient < -0.025 ? 0 :
                        gradient < -0.005 ? 1 :
                            gradient < 0 ? 2 :
                                gradient < 0.005 ? 3 :
                                    gradient < 0.025 ? 4 :
                                        gradient < 0.045 ? 5 :
                                            gradient < 0.065 ? 6 :
                                                gradient < 0.085 ? 7 : 8;
                var mpg = interpolate_curve(fuel_efficiency_curves[gradient_class],
                    2.23694 * (span.dynamicSpeedInfo.trafficSpeed ? span.dynamicSpeedInfo.trafficSpeed : span.dynamicSpeedInfo.baseSpeed));
                route.fuel += 2.35215 / mpg * span.length / 1000;
            }
        }

        function handle_route(route) {
            successful_requests += 1;
            // Skip results that have the exact polylines seen before
            if (routes.every(r => r.polyline != route.polyline)) {
                decorate_spans(route);
                calculate_tolls(route);
                calculate_fuel(route);
                route.background_polyline = new H.map.Polyline(H.geo.LineString.fromFlexiblePolyline(route.polyline), { style: { strokeColor: "#ffffff", lineWidth: 1 } });
                routes.push(route);
                background_polylines.addObject(route.background_polyline);
                render_efficient_frontier();
                for (road of route.toll_roads) {
                    if (!road.toll) continue;
                    for (spans of road.key_spans) {
                        var new_avoid = Object.assign({}, route.avoid);
                        if (!new_avoid.hasOwnProperty("segments")) {
                            new_avoid = Object.assign(new_avoid, { 'segments': [] });
                        }
                        new_avoid.segments = new Set(new_avoid.segments);
                        for (span of spans) {
                            new_avoid.segments.add(span.segmentRef);
                        }
                        new_avoid.segments = Array.from(new_avoid.segments).sort();
                        if (tried_avoids.every(a => !a || !arrayEquals(a.segments, new_avoid.segments))) {
                            tried_avoids.push(new_avoid);
                            calculateRoute(from, to, new_avoid);
                        }
                    }
                }
            }
            render_progress();
        }

        function to_gpx(route) {
            let doc = new DOMParser().parseFromString('<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd" version="1.1"><metadata/><trk><name></name><desc></desc><trkseg></trkseg></trk></gpx>', "application/xml");
            let trkseg = doc.getElementsByTagName("trkseg")[0];
            for (let span of route.spans) {
                let write_time = true;
                new H.geo.LineString(span.shape).eachLatLngAlt((lat, lng, alt) => {
                    var trkpt = doc.createElement("trkpt");
                    trkpt.setAttribute("lat", lat.toFixed(6));
                    trkpt.setAttribute("lon", lng.toFixed(6));
                    var ele = doc.createElement("ele");
                    ele.append(alt.toFixed(0));
                    trkpt.append(ele);
                    if (write_time) {
                        var time = doc.createElement("time");
                        time.append(span.start_time.toISOString());
                        trkpt.append(time);
                        write_time = false;
                    }
                    trkseg.append(trkpt);
                });
            }
            var end_time = doc.createElement("time");
            end_time.append(new Date(route.start_time.getTime() + route.summary.duration * 1000).toISOString());
            var trkpts = trkseg.lastChild.append(end_time);
            return new XMLSerializer().serializeToString(doc).replaceAll('<trkpt xmlns=""', '<trkpt');
        }

        function render_progress() {
            if (routes.length) {
                document.getElementById("progress").innerHTML = `<b>${successful_requests} / ${initiated_requests} combinations tried.<br>` +
                    `${routes.length} unique routes discovered.</b>`;
            }
        }

        function render_efficient_frontier(force = false) {
            const fuel_cost = document.getElementById("fuel-cost").valueAsNumber;
            const time_cost = document.getElementById("hour-cost").valueAsNumber / 3600;
            for (let route of routes) {
                route.fuel_cost = route.fuel * fuel_cost;
                route.time_cost = route.summary.duration * time_cost;
                route.money_cost = route.fuel_cost + route.toll;
                route.cost = route.money_cost + route.time_cost;
            }
            let new_frontier_routes = []
            for (const route of [...routes].sort((a, b) => a.summary.duration - b.summary.duration)) {
                if (!new_frontier_routes.length || route.money_cost < new_frontier_routes[new_frontier_routes.length - 1].money_cost) {
                    new_frontier_routes.push(route);
                }
            }

            let best_route;
            const frontier_routes_sorted_by_cost = [...new_frontier_routes].sort((a, b) => a.cost - b.cost);
            for (let [rank, route] of frontier_routes_sorted_by_cost.entries()) {
                route.cost_rank = rank;
                if (rank == 0) {
                    best_route = route;
                }
            }
            if (!force && arrayEquals(frontier_routes, new_frontier_routes)) {
                render_graph(frontier_routes, best_route, time_cost);
                return;
            } else {
                frontier_routes = new_frontier_routes;
            }

            document.getElementById("results").innerHTML = "";
            for (let route of frontier_routes) {
                route.color = rgbToHex(evaluate_cmap(0.9 - 0.75 * (
                    (route.money_cost - frontier_routes[frontier_routes.length - 1].money_cost) /
                    Math.max(frontier_routes[0].money_cost - frontier_routes[frontier_routes.length - 1].money_cost, 2)
                ), 'turbo', false));
                render_result(route);
            }

            render_graph(frontier_routes, best_route, time_cost);

            let bounding_box;
            frontier_polylines.removeAll();
            for (const route of frontier_routes_sorted_by_cost.reverse()) {
                let polyline = new H.map.Polyline(route.background_polyline.getGeometry(),
                    { style: { strokeColor: route.color, lineWidth: route.cost_rank == 0 ? 5 : route.cost_rank < 3 ? 3 : 2 } });
                frontier_polylines.addObject(polyline);
                bounding_box = bounding_box ? bounding_box.mergeRect(polyline.getBoundingBox()) : polyline.getBoundingBox();
            }
            map.getViewModel().setLookAtData({ bounds: bounding_box });
        }

        function render_result(route) {
            var li = document.createElement("li");
            li.className = `rank${route.cost_rank}`;
            li.style = `color: ${route.color}`;
            li.onclick = () => {
                const gpx = to_gpx(route);
                const blob = new Blob([gpx], { type: "application/gpx+xml" });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `route-${route.start_time.toISOString().replaceAll(/[:-T]/g, '').slice(0, 14)}-` +
                    `${Array.from(frontier_routes.entries()).filter(([i, r]) => r == route)[0][0]}.gpx`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }
            li.innerHTML +=
                `${(route.summary.duration / 60).toFixed(0)}′ ` +
                `(${route.summary.baseDuration > route.summary.duration ? "" : "+"}` +
                `${((route.summary.duration - route.summary.baseDuration) / 60).toFixed(0)}) · ` +
                `$${(route.money_cost).toFixed(2)} · ` +
                `${(route.summary.length / 1000).toFixed(1)}km · ` +
                `${route.fuel.toFixed(2)}L` +
                // TODO `<br>via ${route.label.join(", ")}` +
                `<br><small>${(route.toll ? route.toll_roads : [])
                    .filter(x => !!x.toll)
                    .map(x => `${is_fixed_rate_tollway(x.name) ? x.name : [x.entry, x.name, x.exit].join(" › ")} · ` +
                        `\$${x.toll.toFixed(2)}`).join("<br>")}</small>`
            document.getElementById("results").appendChild(li);
        }

        function render_graph(frontier_routes, best_route, time_cost) {
            if (frontier_routes.length < 2) {
                document.getElementById("graph").style = "display:none";
                return;
            }
            const max_time = frontier_routes[frontier_routes.length - 1].summary.duration;
            const max_cost = frontier_routes[0].money_cost;
            document.getElementById("graph").style = "";
            all_routes = {
                x: routes.map(x => x.summary.duration < max_time ? x.summary.duration : undefined),
                y: routes.map(x => x.money_cost < max_cost ? ((x.money_cost).toFixed(2)) : undefined),
                mode: 'markers',
                marker: {
                    color: '#ffffff',
                    size: 2
                }

            }
            frontier_line = {
                x: frontier_routes.map(x => x.summary.duration),
                y: frontier_routes.map(x => x.money_cost),
                mode: 'lines',
                line: {
                    color: '#444',
                    width: 2
                }
            }
            frontier_points = frontier_routes.map(r => {
                return {
                    x: [r.summary.duration],
                    y: [r.money_cost],
                    mode: 'markers',
                    marker: { color: r.color, size: r.cost_rank == 0 ? 10 : 5 }
                }
            });
            let shapes = [{
                type: 'line',
                x0: frontier_routes[0].summary.duration,
                y0: best_route.money_cost + (best_route.summary.duration - frontier_routes[0].summary.duration) * time_cost,
                x1: best_route.summary.duration + (best_route.money_cost - frontier_routes[frontier_routes.length - 1].money_cost) / time_cost,
                y1: frontier_routes[frontier_routes.length - 1].money_cost,
                line: {
                    color: "white",
                    width: 1,
                    dash: 'dot'
                }
            }];
            if (frontier_routes[0].cost / time_cost <= frontier_routes[frontier_routes.length - 1].summary.duration) {
                shapes.push({
                    type: 'line',
                    x0: frontier_routes[0].cost / time_cost,
                    y0: frontier_routes[0].money_cost,
                    x1: frontier_routes[0].cost / time_cost,
                    y1: frontier_routes[frontier_routes.length - 1].money_cost,
                    line: {
                        color: "#444",
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
            Plotly.newPlot("graph", [all_routes, frontier_line, ...frontier_points], {
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 0,
                    pad: 0
                },
                paper_bgcolor: '#000000',
                plot_bgcolor: '#000000',
                shapes: shapes,
                showlegend: false,
            }, { staticPlot: true });
        }

        function reverse() {
            a = document.getElementById("from").value;
            document.getElementById("from").value = document.getElementById("to").value;
            document.getElementById("to").value = a;
        }

        function arrayEquals(a, b) {
            return Array.isArray(a) &&
                Array.isArray(b) &&
                a.length === b.length &&
                a.every((val, index) => val === b[index]);
        }

        const rgbToHex = (rgb) => '#' + rgb.map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex
        }).join('')

        const _zero2D = [0, 0]

        function closestPointBetween2D(p, a, b) {
            const v = [b[0] - a[0], b[1] - a[1]];;
            const u = [a[0] - p[0], a[1] - p[1]];
            const vu = v[0] * u[0] + v[1] * u[1];
            const vv = v[0] ** 2 + v[1] ** 2;
            const t = -vu / vv
            return t < 0 ? a : t > 1 ? b : [
                (1 - t) * a[0] + t * b[0] - p[0],
                (1 - t) * a[1] + t * b[1] - p[1],
            ];
        }
    </script>
</body>

</html>
